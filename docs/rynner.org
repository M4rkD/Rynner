* ConfigManager
** validation logic for 

interface between runner and runnable

* Runner
abstracts the cluster or generic runner which will run the job
Runner.config returns a new Runnable object, which points to an instance of Runner


Runnable should throw a specific error type if API is violated (i.e. non-existant methods are called)

Change behaviour?



Runner needs to:
have behaviour injected for different clusters -> compose with a host adapter?
have behaviour different plugin/cluster combinations


how does Runner/Plugin logic

* Main logic
** Create (load) Plugin objects
   - find each plugin and load it
   - loop over Plugin.__subclasses__()

   - Plugin object gets it's default supported runners from class variables
   - Plugin.__init__ adds Plugin to a Plugin class variable
   - Runners are included/setup somehow...!???? with the plugin-specific data
   - Runner (classes) are checked against plugin-supported runner interface (somehow)
   - dict passed in to config input spec, and InputSpecification object created and stored internally
     * this InputSpecification object allows adding dynamic config behaviour
     * eventually we can also pass InputSpecification into __init__

 (either from base class & config file or custom class in package)


 - specified by data??

Plugin distributed with its own Runners (or a git

Load compatible built-in runners (specified as a list of class names)
 (specified as a list of class names for internal, pluggable runners are set at a plugin-only leve)

 or file path for plugins? CLASH!!!)
   - look for Plugin-Cluster data/config files, load into run_type.runner_data
** Create (load) Runners from config files
   config file
** Load runner-specific config data into the Plugin object
** Create Qt views and models, link them together

--> load the runners and their config


config = QConfigManager(a)



APP MANAGER IS CONNECT TO TOO MUCH STUFF....!


* PROBLEM
Plugin is initialised IN the framwork currently...this doesn't work


* Prev design
** Job
- data container for job data
- contains no update logic
- updated by QueueManager
- acts as a standardised interface for jobs

** QueueManager (SlurmManager)
- singleton object which stores jobs list in a member variable
- updates jobs list
- abstracts storage/querying of jobs
- has a well-defined interfaces for creating/running new jobs
- methods for sending/receiving files
- defines a current working directory
- writes job scripts (internally)

** ApplicationAdapter
- run method - abstract method called by callee
- setup method (does nothing for now)
- finished method (does nothing)
- other...?

** ApplicationManager
- runs event queue
- listens for calls from scripts and delegates actions to ApplicationAdapter/QueueManager
- Polls for finished jobs
- Calls 'finished' action of ApplicationAdapter when job finishes
- Calls 'setup' and 'run' method of ApplicationAdapter as appropriate

** Other (non-class) scripts
- sends messages to ApplicationManager
